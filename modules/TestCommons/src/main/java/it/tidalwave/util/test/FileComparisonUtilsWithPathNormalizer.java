/*
 * *********************************************************************************************************************
 *
 * blueMarine II: Semantic Media Centre
 * http://tidalwave.it/projects/bluemarine2
 *
 * Copyright (C) 2015 - 2021 by Tidalwave s.a.s. (http://tidalwave.it)
 *
 * *********************************************************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * *********************************************************************************************************************
 *
 * git clone https://bitbucket.org/tidalwave/bluemarine2-src
 * git clone https://github.com/tidalwave-it/bluemarine2-src
 *
 * *********************************************************************************************************************
 */
package it.tidalwave.util.test;

import javax.annotation.Nonnull;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.nio.file.Files;
import java.nio.file.Path;
import org.eclipse.rdf4j.rio.RDFFormat;
import org.eclipse.rdf4j.rio.RDFParser;
import org.eclipse.rdf4j.rio.Rio;
import org.eclipse.rdf4j.rio.n3.N3Writer;
import lombok.extern.slf4j.Slf4j;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
import static it.tidalwave.bluemarine2.util.PathNormalization.*;

/***********************************************************************************************************************
 *
 * @author  Fabrizio Giudici
 *
 **********************************************************************************************************************/
@Slf4j
public class FileComparisonUtilsWithPathNormalizer
  {
    public static void assertSameContents (@Nonnull final Path expectedPath, @Nonnull final Path actualPath)
      throws IOException
      {
        FileComparisonUtils.assertSameContents(normalizedPath(expectedPath.toAbsolutePath()),
                                               normalizedPath(actualPath.toAbsolutePath()));
      }

    public static void rewriteN3 (@Nonnull final Path file)
            throws IOException
      {
        rewriteN3(file, true);
      }

    /*******************************************************************************************************************
     *
     * Rewrites a N3 file with the current RDF4J runtime. This takes care of eventual differences in formatting from
     * version to version and makes it possible to use in tests 'expected files' generated by a previous version with
     * a different formatting.
     *
     * @param   file              the file to rewrite
     * @param   removeDoubleBlankLines
     * @throws  IOException       in case of error
     *
     ******************************************************************************************************************/
    public static void rewriteN3 (@Nonnull final Path file, boolean removeDoubleBlankLines)
            throws IOException
      {
        log.warn("Rewriting {} ... (original file is preserved with .orig suffix)", file);
        assert file.toString().contains("target") : "You must not call rewriteN3() on a file in sources";

        final Path normalizedFile = normalizedPath(file.toAbsolutePath());
        final Path originalFile = normalizedFile.getParent().resolve(file.getFileName() + ".orig");
        Files.createDirectories(originalFile.getParent());
        Files.copy(normalizedFile, originalFile, REPLACE_EXISTING);

        try (final Writer w = Files.newBufferedWriter(normalizedFile, UTF_8);
             final Reader r = Files.newBufferedReader(originalFile, UTF_8))
          {
            final N3Writer n3Writer = new N3Writer(w);
            final RDFParser rdfParser = Rio.createParser(RDFFormat.N3);
            rdfParser.setRDFHandler(n3Writer);
            rdfParser.setPreserveBNodeIDs(true);
            rdfParser.parse(r, "");
          }

        if (removeDoubleBlankLines)
          {
            // Remove a double blank line after namespaces
            String contents = Files.readString(normalizedFile, UTF_8);

            if (contents.endsWith("\n\n"))
              {
                contents = contents.substring(0, contents.length() - 1);
              }

            // in case there are only namespaces
            contents = contents.replaceAll("\n\n\n", "\n\n");
            Files.writeString(normalizedFile, contents, UTF_8);
          }
      }
  }
